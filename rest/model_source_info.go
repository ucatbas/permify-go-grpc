/*
Permify API

Permify is an open source authorization service for creating fine-grained and scalable authorization systems.

API version: v0.10.1
Contact: hello@permify.co
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package permify

import (
	"encoding/json"
)

// checks if the SourceInfo type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &SourceInfo{}

// SourceInfo Source information collected at parse time.
type SourceInfo struct {
	// The syntax version of the source, e.g. `cel1`.
	SyntaxVersion *string `json:"syntaxVersion,omitempty"`
	// The location name. All position information attached to an expression is relative to this location.  The location could be a file, UI element, or similar. For example, `acme/app/AnvilPolicy.cel`.
	Location *string `json:"location,omitempty"`
	// Monotonically increasing list of code point offsets where newlines `\\n` appear.  The line number of a given position is the index `i` where for a given `id` the `line_offsets[i] < id_positions[id] < line_offsets[i+1]`. The column may be derivd from `id_positions[id] - line_offsets[i]`.
	LineOffsets []int32 `json:"lineOffsets,omitempty"`
	// A map from the parse node id (e.g. `Expr.id`) to the code point offset within the source.
	Positions *map[string]int32 `json:"positions,omitempty"`
	// A map from the parse node id where a macro replacement was made to the call `Expr` that resulted in a macro expansion.  For example, `has(value.field)` is a function call that is replaced by a `test_only` field selection in the AST. Likewise, the call `list.exists(e, e > 10)` translates to a comprehension expression. The key in the map corresponds to the expression id of the expanded macro, and the value is the call `Expr` that was replaced.
	MacroCalls *map[string]Expr `json:"macroCalls,omitempty"`
}

// NewSourceInfo instantiates a new SourceInfo object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewSourceInfo() *SourceInfo {
	this := SourceInfo{}
	return &this
}

// NewSourceInfoWithDefaults instantiates a new SourceInfo object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewSourceInfoWithDefaults() *SourceInfo {
	this := SourceInfo{}
	return &this
}

// GetSyntaxVersion returns the SyntaxVersion field value if set, zero value otherwise.
func (o *SourceInfo) GetSyntaxVersion() string {
	if o == nil || IsNil(o.SyntaxVersion) {
		var ret string
		return ret
	}
	return *o.SyntaxVersion
}

// GetSyntaxVersionOk returns a tuple with the SyntaxVersion field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SourceInfo) GetSyntaxVersionOk() (*string, bool) {
	if o == nil || IsNil(o.SyntaxVersion) {
		return nil, false
	}
	return o.SyntaxVersion, true
}

// HasSyntaxVersion returns a boolean if a field has been set.
func (o *SourceInfo) HasSyntaxVersion() bool {
	if o != nil && !IsNil(o.SyntaxVersion) {
		return true
	}

	return false
}

// SetSyntaxVersion gets a reference to the given string and assigns it to the SyntaxVersion field.
func (o *SourceInfo) SetSyntaxVersion(v string) {
	o.SyntaxVersion = &v
}

// GetLocation returns the Location field value if set, zero value otherwise.
func (o *SourceInfo) GetLocation() string {
	if o == nil || IsNil(o.Location) {
		var ret string
		return ret
	}
	return *o.Location
}

// GetLocationOk returns a tuple with the Location field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SourceInfo) GetLocationOk() (*string, bool) {
	if o == nil || IsNil(o.Location) {
		return nil, false
	}
	return o.Location, true
}

// HasLocation returns a boolean if a field has been set.
func (o *SourceInfo) HasLocation() bool {
	if o != nil && !IsNil(o.Location) {
		return true
	}

	return false
}

// SetLocation gets a reference to the given string and assigns it to the Location field.
func (o *SourceInfo) SetLocation(v string) {
	o.Location = &v
}

// GetLineOffsets returns the LineOffsets field value if set, zero value otherwise.
func (o *SourceInfo) GetLineOffsets() []int32 {
	if o == nil || IsNil(o.LineOffsets) {
		var ret []int32
		return ret
	}
	return o.LineOffsets
}

// GetLineOffsetsOk returns a tuple with the LineOffsets field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SourceInfo) GetLineOffsetsOk() ([]int32, bool) {
	if o == nil || IsNil(o.LineOffsets) {
		return nil, false
	}
	return o.LineOffsets, true
}

// HasLineOffsets returns a boolean if a field has been set.
func (o *SourceInfo) HasLineOffsets() bool {
	if o != nil && !IsNil(o.LineOffsets) {
		return true
	}

	return false
}

// SetLineOffsets gets a reference to the given []int32 and assigns it to the LineOffsets field.
func (o *SourceInfo) SetLineOffsets(v []int32) {
	o.LineOffsets = v
}

// GetPositions returns the Positions field value if set, zero value otherwise.
func (o *SourceInfo) GetPositions() map[string]int32 {
	if o == nil || IsNil(o.Positions) {
		var ret map[string]int32
		return ret
	}
	return *o.Positions
}

// GetPositionsOk returns a tuple with the Positions field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SourceInfo) GetPositionsOk() (*map[string]int32, bool) {
	if o == nil || IsNil(o.Positions) {
		return nil, false
	}
	return o.Positions, true
}

// HasPositions returns a boolean if a field has been set.
func (o *SourceInfo) HasPositions() bool {
	if o != nil && !IsNil(o.Positions) {
		return true
	}

	return false
}

// SetPositions gets a reference to the given map[string]int32 and assigns it to the Positions field.
func (o *SourceInfo) SetPositions(v map[string]int32) {
	o.Positions = &v
}

// GetMacroCalls returns the MacroCalls field value if set, zero value otherwise.
func (o *SourceInfo) GetMacroCalls() map[string]Expr {
	if o == nil || IsNil(o.MacroCalls) {
		var ret map[string]Expr
		return ret
	}
	return *o.MacroCalls
}

// GetMacroCallsOk returns a tuple with the MacroCalls field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SourceInfo) GetMacroCallsOk() (*map[string]Expr, bool) {
	if o == nil || IsNil(o.MacroCalls) {
		return nil, false
	}
	return o.MacroCalls, true
}

// HasMacroCalls returns a boolean if a field has been set.
func (o *SourceInfo) HasMacroCalls() bool {
	if o != nil && !IsNil(o.MacroCalls) {
		return true
	}

	return false
}

// SetMacroCalls gets a reference to the given map[string]Expr and assigns it to the MacroCalls field.
func (o *SourceInfo) SetMacroCalls(v map[string]Expr) {
	o.MacroCalls = &v
}

func (o SourceInfo) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o SourceInfo) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.SyntaxVersion) {
		toSerialize["syntaxVersion"] = o.SyntaxVersion
	}
	if !IsNil(o.Location) {
		toSerialize["location"] = o.Location
	}
	if !IsNil(o.LineOffsets) {
		toSerialize["lineOffsets"] = o.LineOffsets
	}
	if !IsNil(o.Positions) {
		toSerialize["positions"] = o.Positions
	}
	if !IsNil(o.MacroCalls) {
		toSerialize["macroCalls"] = o.MacroCalls
	}
	return toSerialize, nil
}

type NullableSourceInfo struct {
	value *SourceInfo
	isSet bool
}

func (v NullableSourceInfo) Get() *SourceInfo {
	return v.value
}

func (v *NullableSourceInfo) Set(val *SourceInfo) {
	v.value = val
	v.isSet = true
}

func (v NullableSourceInfo) IsSet() bool {
	return v.isSet
}

func (v *NullableSourceInfo) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableSourceInfo(val *SourceInfo) *NullableSourceInfo {
	return &NullableSourceInfo{value: val, isSet: true}
}

func (v NullableSourceInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableSourceInfo) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


