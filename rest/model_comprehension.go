/*
Permify API

Permify is an open source authorization service for creating fine-grained and scalable authorization systems.

API version: v0.10.1
Contact: hello@permify.co
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package permify

import (
	"encoding/json"
)

// checks if the Comprehension type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Comprehension{}

// Comprehension A comprehension expression applied to a list or map.  Comprehensions are not part of the core syntax, but enabled with macros. A macro matches a specific call signature within a parsed AST and replaces the call with an alternate AST block. Macro expansion happens at parse time.  The following macros are supported within CEL:  Aggregate type macros may be applied to all elements in a list or all keys in a map:  *  `all`, `exists`, `exists_one` -  test a predicate expression against    the inputs and return `true` if the predicate is satisfied for all,    any, or only one value `list.all(x, x < 10)`. *  `filter` - test a predicate expression against the inputs and return    the subset of elements which satisfy the predicate:    `payments.filter(p, p > 1000)`. *  `map` - apply an expression to all elements in the input and return the    output aggregate type: `[1, 2, 3].map(i, i * i)`.  The `has(m.x)` macro tests whether the property `x` is present in struct `m`. The semantics of this macro depend on the type of `m`. For proto2 messages `has(m.x)` is defined as 'defined, but not set`. For proto3, the macro tests whether the property is set to its default. For map and struct types, the macro tests whether the property `x` is defined on `m`.
type Comprehension struct {
	// The name of the iteration variable.
	IterVar *string `json:"iterVar,omitempty"`
	IterRange *Expr `json:"iterRange,omitempty"`
	// The name of the variable used for accumulation of the result.
	AccuVar *string `json:"accuVar,omitempty"`
	AccuInit *Expr `json:"accuInit,omitempty"`
	LoopCondition *Expr `json:"loopCondition,omitempty"`
	LoopStep *Expr `json:"loopStep,omitempty"`
	Result *Expr `json:"result,omitempty"`
}

// NewComprehension instantiates a new Comprehension object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewComprehension() *Comprehension {
	this := Comprehension{}
	return &this
}

// NewComprehensionWithDefaults instantiates a new Comprehension object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewComprehensionWithDefaults() *Comprehension {
	this := Comprehension{}
	return &this
}

// GetIterVar returns the IterVar field value if set, zero value otherwise.
func (o *Comprehension) GetIterVar() string {
	if o == nil || IsNil(o.IterVar) {
		var ret string
		return ret
	}
	return *o.IterVar
}

// GetIterVarOk returns a tuple with the IterVar field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Comprehension) GetIterVarOk() (*string, bool) {
	if o == nil || IsNil(o.IterVar) {
		return nil, false
	}
	return o.IterVar, true
}

// HasIterVar returns a boolean if a field has been set.
func (o *Comprehension) HasIterVar() bool {
	if o != nil && !IsNil(o.IterVar) {
		return true
	}

	return false
}

// SetIterVar gets a reference to the given string and assigns it to the IterVar field.
func (o *Comprehension) SetIterVar(v string) {
	o.IterVar = &v
}

// GetIterRange returns the IterRange field value if set, zero value otherwise.
func (o *Comprehension) GetIterRange() Expr {
	if o == nil || IsNil(o.IterRange) {
		var ret Expr
		return ret
	}
	return *o.IterRange
}

// GetIterRangeOk returns a tuple with the IterRange field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Comprehension) GetIterRangeOk() (*Expr, bool) {
	if o == nil || IsNil(o.IterRange) {
		return nil, false
	}
	return o.IterRange, true
}

// HasIterRange returns a boolean if a field has been set.
func (o *Comprehension) HasIterRange() bool {
	if o != nil && !IsNil(o.IterRange) {
		return true
	}

	return false
}

// SetIterRange gets a reference to the given Expr and assigns it to the IterRange field.
func (o *Comprehension) SetIterRange(v Expr) {
	o.IterRange = &v
}

// GetAccuVar returns the AccuVar field value if set, zero value otherwise.
func (o *Comprehension) GetAccuVar() string {
	if o == nil || IsNil(o.AccuVar) {
		var ret string
		return ret
	}
	return *o.AccuVar
}

// GetAccuVarOk returns a tuple with the AccuVar field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Comprehension) GetAccuVarOk() (*string, bool) {
	if o == nil || IsNil(o.AccuVar) {
		return nil, false
	}
	return o.AccuVar, true
}

// HasAccuVar returns a boolean if a field has been set.
func (o *Comprehension) HasAccuVar() bool {
	if o != nil && !IsNil(o.AccuVar) {
		return true
	}

	return false
}

// SetAccuVar gets a reference to the given string and assigns it to the AccuVar field.
func (o *Comprehension) SetAccuVar(v string) {
	o.AccuVar = &v
}

// GetAccuInit returns the AccuInit field value if set, zero value otherwise.
func (o *Comprehension) GetAccuInit() Expr {
	if o == nil || IsNil(o.AccuInit) {
		var ret Expr
		return ret
	}
	return *o.AccuInit
}

// GetAccuInitOk returns a tuple with the AccuInit field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Comprehension) GetAccuInitOk() (*Expr, bool) {
	if o == nil || IsNil(o.AccuInit) {
		return nil, false
	}
	return o.AccuInit, true
}

// HasAccuInit returns a boolean if a field has been set.
func (o *Comprehension) HasAccuInit() bool {
	if o != nil && !IsNil(o.AccuInit) {
		return true
	}

	return false
}

// SetAccuInit gets a reference to the given Expr and assigns it to the AccuInit field.
func (o *Comprehension) SetAccuInit(v Expr) {
	o.AccuInit = &v
}

// GetLoopCondition returns the LoopCondition field value if set, zero value otherwise.
func (o *Comprehension) GetLoopCondition() Expr {
	if o == nil || IsNil(o.LoopCondition) {
		var ret Expr
		return ret
	}
	return *o.LoopCondition
}

// GetLoopConditionOk returns a tuple with the LoopCondition field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Comprehension) GetLoopConditionOk() (*Expr, bool) {
	if o == nil || IsNil(o.LoopCondition) {
		return nil, false
	}
	return o.LoopCondition, true
}

// HasLoopCondition returns a boolean if a field has been set.
func (o *Comprehension) HasLoopCondition() bool {
	if o != nil && !IsNil(o.LoopCondition) {
		return true
	}

	return false
}

// SetLoopCondition gets a reference to the given Expr and assigns it to the LoopCondition field.
func (o *Comprehension) SetLoopCondition(v Expr) {
	o.LoopCondition = &v
}

// GetLoopStep returns the LoopStep field value if set, zero value otherwise.
func (o *Comprehension) GetLoopStep() Expr {
	if o == nil || IsNil(o.LoopStep) {
		var ret Expr
		return ret
	}
	return *o.LoopStep
}

// GetLoopStepOk returns a tuple with the LoopStep field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Comprehension) GetLoopStepOk() (*Expr, bool) {
	if o == nil || IsNil(o.LoopStep) {
		return nil, false
	}
	return o.LoopStep, true
}

// HasLoopStep returns a boolean if a field has been set.
func (o *Comprehension) HasLoopStep() bool {
	if o != nil && !IsNil(o.LoopStep) {
		return true
	}

	return false
}

// SetLoopStep gets a reference to the given Expr and assigns it to the LoopStep field.
func (o *Comprehension) SetLoopStep(v Expr) {
	o.LoopStep = &v
}

// GetResult returns the Result field value if set, zero value otherwise.
func (o *Comprehension) GetResult() Expr {
	if o == nil || IsNil(o.Result) {
		var ret Expr
		return ret
	}
	return *o.Result
}

// GetResultOk returns a tuple with the Result field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Comprehension) GetResultOk() (*Expr, bool) {
	if o == nil || IsNil(o.Result) {
		return nil, false
	}
	return o.Result, true
}

// HasResult returns a boolean if a field has been set.
func (o *Comprehension) HasResult() bool {
	if o != nil && !IsNil(o.Result) {
		return true
	}

	return false
}

// SetResult gets a reference to the given Expr and assigns it to the Result field.
func (o *Comprehension) SetResult(v Expr) {
	o.Result = &v
}

func (o Comprehension) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Comprehension) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.IterVar) {
		toSerialize["iterVar"] = o.IterVar
	}
	if !IsNil(o.IterRange) {
		toSerialize["iterRange"] = o.IterRange
	}
	if !IsNil(o.AccuVar) {
		toSerialize["accuVar"] = o.AccuVar
	}
	if !IsNil(o.AccuInit) {
		toSerialize["accuInit"] = o.AccuInit
	}
	if !IsNil(o.LoopCondition) {
		toSerialize["loopCondition"] = o.LoopCondition
	}
	if !IsNil(o.LoopStep) {
		toSerialize["loopStep"] = o.LoopStep
	}
	if !IsNil(o.Result) {
		toSerialize["result"] = o.Result
	}
	return toSerialize, nil
}

type NullableComprehension struct {
	value *Comprehension
	isSet bool
}

func (v NullableComprehension) Get() *Comprehension {
	return v.value
}

func (v *NullableComprehension) Set(val *Comprehension) {
	v.value = val
	v.isSet = true
}

func (v NullableComprehension) IsSet() bool {
	return v.isSet
}

func (v *NullableComprehension) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableComprehension(val *Comprehension) *NullableComprehension {
	return &NullableComprehension{value: val, isSet: true}
}

func (v NullableComprehension) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableComprehension) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


